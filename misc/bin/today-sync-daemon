#!/usr/bin/env bash

# today-sync-daemon - Sync today's section between TODAY.md and TODO.md
# Monitors both files with inotify and keeps current day's content in sync

set -euo pipefail

# ==============================================================================
# CONFIGURATION
# ==============================================================================

TODAY_FILE="$HOME/Documents/TODAY.md"
TODO_FILE="$HOME/wiki/TODO.md"
STATE_DIR="$HOME/.local/state"
STATE_FILE="$STATE_DIR/today-sync-state"
SENTINEL_FILE="/tmp/today-sync-running"
SENTINEL_TIMEOUT=60  # seconds
DEBOUNCE_DELAY=0.5  # seconds

# ==============================================================================
# LOGGING
# ==============================================================================

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
}

log_error() {
    log "ERROR: $*" >&2
}

# ==============================================================================
# HELPERS
# ==============================================================================

# Get today's date once, reuse throughout
get_today_date() {
    date '+%Y-%m-%d'
}

# Get today's week number
get_week_number() {
    date '+%U'
}

# Extract just the date portion from ISO timestamp
extract_date_from_timestamp() {
    local timestamp="$1"
    echo "${timestamp%%T*}"
}

# ==============================================================================
# INITIALIZATION
# ==============================================================================

ensure_state_dir() {
    if [[ ! -d "$STATE_DIR" ]]; then
        mkdir -p "$STATE_DIR"
        log "Created state directory: $STATE_DIR"
    fi
}

initialize_files() {
    local today_date
    today_date=$(get_today_date)
    local today_week
    today_week=$(get_week_number)

    # Ensure parent directories exist
    local today_dir todo_dir
    today_dir=$(dirname "$TODAY_FILE")
    todo_dir=$(dirname "$TODO_FILE")
    
    if [[ ! -d "$today_dir" ]]; then
        mkdir -p "$today_dir"
        log "Created directory: $today_dir"
    fi
    
    if [[ ! -d "$todo_dir" ]]; then
        mkdir -p "$todo_dir"
        log "Created directory: $todo_dir"
    fi

    # Create TODAY.md if missing
    if [[ ! -f "$TODAY_FILE" ]]; then
        local today_section
        today_section=$(extract_today_section_from_file "$TODO_FILE" "$today_date")
        if [[ -n "$today_section" ]]; then
            echo "$today_section" > "$TODAY_FILE"
            log "Created TODAY.md from existing TODO.md entry"
        else
            echo "## $today_date - Week ${today_week}" > "$TODAY_FILE"
            log "Created TODAY.md with new date header"
        fi
    fi

    # Create TODO.md if missing
    if [[ ! -f "$TODO_FILE" ]]; then
        {
            echo "## INBOX"
            echo ""
            extract_today_section_from_file "$TODAY_FILE" "$today_date"
        } > "$TODO_FILE"
        log "Created TODO.md with INBOX and today's section"
    fi
}

# ==============================================================================
# AWK FUNCTIONS
# ==============================================================================

# Extract today's section from a file
# Usage: extract_today_section_from_file <file> <date>
extract_today_section_from_file() {
    local file="$1"
    local date="$2"

    [[ ! -f "$file" ]] && return

    awk -v target_date="$date" '
        BEGIN { in_today = 0; found = 0; header = "" }
        /^## [0-9]{4}-[0-9]{2}-[0-9]{2}/ {
            if ($0 ~ target_date) {
                in_today = 1
                found = 1
                header = $0
                next
            } else if (in_today) {
                exit
            }
        }
        in_today {
            if (length(header) > 0) {
                print header
                header = ""
            }
            print
        }
    ' "$file"
}

# Update today's section in a file
# Usage: update_today_section_in_file <file> <date> <new_section>
update_today_section_in_file() {
    local file="$1"
    local date="$2"
    local new_section="$3"

    [[ ! -f "$file" ]] && { echo "$new_section"; return; }

    awk -v target_date="$date" -v new_content="$new_section" '
        BEGIN { in_today = 0; printed = 0; need_blank = 0 }
        /^## [0-9]{4}-[0-9]{2}-[0-9]{2}/ {
            if ($0 ~ target_date) {
                if (need_blank) print ""
                print new_content
                in_today = 1
                printed = 1
                print ""
                next
            } else if (in_today) {
                in_today = 0
            }
        }
        !in_today { print; need_blank = 1 }
        END {
            if (!printed) {
                if (NR > 0) print ""
                print new_content
            }
        }
    ' "$file"
}

# ==============================================================================
# SENTINEL MANAGEMENT
# ==============================================================================

sentinel_exists() {
    [[ ! -f "$SENTINEL_FILE" ]] && return 1

    local sentinel_age
    sentinel_age=$(($(date +%s) - $(stat -c %Y "$SENTINEL_FILE" 2>/dev/null || echo 0)))

    if [[ $sentinel_age -gt $SENTINEL_TIMEOUT ]]; then
        rm -f "$SENTINEL_FILE"
        return 1
    fi
    return 0
}

create_sentinel() {
    (
        flock -x 200
        echo "$$" > "$SENTINEL_FILE"
    ) 200>"$SENTINEL_FILE"
}

remove_sentinel() {
    rm -f "$SENTINEL_FILE"
}

cleanup_on_exit() {
    remove_sentinel
    log "Daemon stopped"
}

trap cleanup_on_exit EXIT INT TERM

# ==============================================================================
# STATE MANAGEMENT
# ==============================================================================

get_stored_hash() {
    [[ ! -f "$STATE_FILE" ]] && return
    grep '^last_synced_hash=' "$STATE_FILE" 2>/dev/null | cut -d'=' -f2
}

store_hash() {
    local hash="$1"
    local source="$2"
    local timestamp
    timestamp=$(date -Iseconds)

    cat > "$STATE_FILE" <<EOF
last_synced_hash=$hash
last_sync_time=$timestamp
last_synced_from=$source
EOF
}

compute_hash() {
    echo -n "$1" | sha256sum | cut -d' ' -f1
}

get_last_sync_date() {
    [[ ! -f "$STATE_FILE" ]] && return
    local last_sync_time
    last_sync_time=$(grep '^last_sync_time=' "$STATE_FILE" 2>/dev/null | cut -d'=' -f2)
    extract_date_from_timestamp "$last_sync_time"
}

# ==============================================================================
# FILE OPERATIONS
# ==============================================================================

get_today_section() {
    local file="$1"
    extract_today_section_from_file "$file" "$(get_today_date)"
}

update_file() {
    local file="$1"
    local content="$2"
    local temp_file="${file}.tmp.$$"

    echo "$content" > "$temp_file"
    mv "$temp_file" "$file"
}

get_file_mtime() {
    stat -c %Y "$1" 2>/dev/null || echo 0
}

# Safely read file with retries (handles temporary Dropbox sync issues)
safe_read_file() {
    local file="$1"
    local max_attempts=3
    local attempt=0
    
    while [[ $attempt -lt $max_attempts ]]; do
        if [[ -f "$file" ]] && [[ -r "$file" ]]; then
            cat "$file" 2>/dev/null && return 0
        fi
        ((attempt++))
        [[ $attempt -lt $max_attempts ]] && sleep 0.1
    done
    return 1
}

# Check if section has content beyond just the header
section_has_content() {
    local section="$1"
    echo "$section" | tail -n +2 | grep -q . && echo yes || echo no
}

# ==============================================================================
# DATE ROLLOVER
# ==============================================================================

handle_date_rollover() {
    local last_sync_date
    last_sync_date=$(get_last_sync_date)
    local current_date
    current_date=$(get_today_date)

    # Initialize on first run or if no date change
    [[ -z "$last_sync_date" ]] && return 0
    [[ "$last_sync_date" == "$current_date" ]] && return 0

    log "Date rolled over from $last_sync_date to $current_date"

    # Check if TODO.md already has the new date section
    local new_section
    new_section=$(extract_today_section_from_file "$TODO_FILE" "$current_date")

    if [[ -n "$new_section" ]]; then
        log "Using existing TODO.md section for $current_date"
    else
        log "Creating new section for $current_date"
        new_section="## $current_date"
        local updated_week
        updated_week=$(get_week_number)
        new_section="## $current_date - Week ${updated_week}"
        local updated
        updated=$(update_today_section_in_file "$TODO_FILE" "$current_date" "$new_section")
        echo "$updated" > "$TODO_FILE"
    fi

    # Update TODAY.md with the new section
    update_file "$TODAY_FILE" "$new_section"

    # Update state
    local new_hash
    new_hash=$(compute_hash "$new_section")
    store_hash "$new_hash" "rollover"

    log "Date rollover complete"
}

# ==============================================================================
# SYNC LOGIC
# ==============================================================================

# Determine which file should be the sync source
determine_sync_source() {
    local today_section="$1"
    local todo_section="$2"
    local today_hash="$3"
    local todo_hash="$4"
    local stored_hash="$5"
    local today_mtime="$6"
    local todo_mtime="$7"

    local today_has_content
    today_has_content=$(section_has_content "$today_section")
    local todo_has_content
    todo_has_content=$(section_has_content "$todo_section")

    # No change in either file
    if [[ "$today_hash" == "$stored_hash" ]] && [[ "$todo_hash" == "$stored_hash" ]]; then
        echo "none"
        return
    fi

    # Prefer the file with actual content when one is empty
    if [[ "$todo_has_content" == "no" ]] && [[ "$today_has_content" == "yes" ]]; then
        echo "$TODAY_FILE"
        return
    fi

    if [[ "$today_has_content" == "no" ]] && [[ "$todo_has_content" == "yes" ]]; then
        echo "$TODO_FILE"
        return
    fi

    # One file changed, other didn't
    if [[ "$today_hash" != "$stored_hash" ]] && [[ "$todo_hash" == "$stored_hash" ]]; then
        echo "$TODAY_FILE"
        return
    fi

    if [[ "$todo_hash" != "$stored_hash" ]] && [[ "$today_hash" == "$stored_hash" ]]; then
        echo "$TODO_FILE"
        return
    fi

    # Both changed - use mtime as tiebreaker
    if [[ $today_mtime -ge $todo_mtime ]]; then
        echo "$TODAY_FILE"
    else
        echo "$TODO_FILE"
    fi
}

sync_today_sections() {
    if sentinel_exists; then
        return
    fi

    create_sentinel

    # Get current sections and hashes
    local today_section todo_section
    local today_hash todo_hash stored_hash
    local today_mtime todo_mtime

    today_section=$(get_today_section "$TODAY_FILE")
    todo_section=$(get_today_section "$TODO_FILE")
    today_mtime=$(get_file_mtime "$TODAY_FILE")
    todo_mtime=$(get_file_mtime "$TODO_FILE")

    # Both empty - nothing to sync
    if [[ -z "$today_section" ]] && [[ -z "$todo_section" ]]; then
        log_error "No today section found in either file"
        remove_sentinel
        return 1
    fi

    # Compute hashes
    today_hash=$(compute_hash "$today_section")
    todo_hash=$(compute_hash "$todo_section")
    stored_hash=$(get_stored_hash)

    # Determine source file
    local source_file
    source_file=$(determine_sync_source \
        "$today_section" "$todo_section" \
        "$today_hash" "$todo_hash" "$stored_hash" \
        "$today_mtime" "$todo_mtime")

    # No sync needed
    if [[ "$source_file" == "none" ]]; then
        remove_sentinel
        return 0
    fi

    # Get section from source
    local section
    section=$(get_today_section "$source_file")

    if [[ -z "$section" ]]; then
        log_error "No today section found in $source_file"
        remove_sentinel
        return 1
    fi

    # Check if content actually changed
    local current_hash
    current_hash=$(compute_hash "$section")

    if [[ "$current_hash" == "$stored_hash" ]]; then
        remove_sentinel
        return 0
    fi

    # Update the target file
    local target_file
    target_file=$([[ "$source_file" == "$TODAY_FILE" ]] && echo "$TODO_FILE" || echo "$TODAY_FILE")
    local today_date
    today_date=$(get_today_date)

    if [[ "$target_file" == "$TODO_FILE" ]]; then
        # Preserve other sections in TODO.md
        local updated
        updated=$(update_today_section_in_file "$target_file" "$today_date" "$section")
        local current_content
        current_content=$(safe_read_file "$target_file")
        [[ "$updated" != "$current_content" ]] && echo "$updated" > "$target_file"
    else
        # Replace entire TODAY.md
        local current_content
        current_content=$(safe_read_file "$target_file")
        [[ "$section" != "$current_content" ]] && update_file "$target_file" "$section"
    fi

    # Store new hash
    store_hash "$current_hash" "$source_file"

    remove_sentinel
}

# ==============================================================================
# DAEMON
# ==============================================================================

cleanup_stale_sentinel() {
    [[ ! -f "$SENTINEL_FILE" ]] && return

    local sentinel_age
    sentinel_age=$(($(date +%s) - $(stat -c %Y "$SENTINEL_FILE" 2>/dev/null || echo 0)))

    if [[ $sentinel_age -gt $SENTINEL_TIMEOUT ]]; then
        rm -f "$SENTINEL_FILE"
        log "Cleaned up stale sentinel"
    fi
}

main() {
    ensure_state_dir
    cleanup_stale_sentinel
    initialize_files

    # Check for inotifywait
    if ! command -v inotifywait &>/dev/null; then
        log_error "inotifywait not found. Please install inotify-tools"
        exit 1
    fi

    # Start background date checker
    (
        while true; do
            sleep 60
            handle_date_rollover || true
        done
    ) &

    # Main inotify loop
    local last_sync=0
    inotifywait -m -e modify,move,attrib,close_write "$TODAY_FILE" "$TODO_FILE" 2>/dev/null | while read -r path event; do
        local now
        now=$(date +%s)

        # Debounce: only sync if enough time has passed
        if [[ $((now - last_sync)) -ge 1 ]]; then
            sleep "$DEBOUNCE_DELAY"
            sync_today_sections || true
            last_sync=$now
        fi
    done
}

main "$@"
